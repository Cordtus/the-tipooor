"use strict";
// @generated by protoc-gen-es v1.5.0 with parameter "target=ts"
// @generated from file cosmos/vesting/v1beta1/vesting.proto (package cosmos.vesting.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermanentLockedAccount = exports.PeriodicVestingAccount = exports.Period = exports.DelayedVestingAccount = exports.ContinuousVestingAccount = exports.BaseVestingAccount = void 0;
const protobuf_1 = require("@bufbuild/protobuf");
const auth_pb_js_1 = require("../../auth/v1beta1/auth_pb.js");
const coin_pb_js_1 = require("../../base/v1beta1/coin_pb.js");
/**
 * BaseVestingAccount implements the VestingAccount interface. It contains all
 * the necessary fields needed for any vesting account implementation.
 *
 * @generated from message cosmos.vesting.v1beta1.BaseVestingAccount
 */
class BaseVestingAccount extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: repeated cosmos.base.v1beta1.Coin original_vesting = 2;
         */
        this.originalVesting = [];
        /**
         * @generated from field: repeated cosmos.base.v1beta1.Coin delegated_free = 3;
         */
        this.delegatedFree = [];
        /**
         * @generated from field: repeated cosmos.base.v1beta1.Coin delegated_vesting = 4;
         */
        this.delegatedVesting = [];
        /**
         * Vesting end time, as unix timestamp (in seconds).
         *
         * @generated from field: int64 end_time = 5;
         */
        this.endTime = protobuf_1.protoInt64.zero;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new BaseVestingAccount().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new BaseVestingAccount().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new BaseVestingAccount().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(BaseVestingAccount, a, b);
    }
}
exports.BaseVestingAccount = BaseVestingAccount;
BaseVestingAccount.runtime = protobuf_1.proto3;
BaseVestingAccount.typeName = "cosmos.vesting.v1beta1.BaseVestingAccount";
BaseVestingAccount.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "base_account", kind: "message", T: auth_pb_js_1.BaseAccount },
    { no: 2, name: "original_vesting", kind: "message", T: coin_pb_js_1.Coin, repeated: true },
    { no: 3, name: "delegated_free", kind: "message", T: coin_pb_js_1.Coin, repeated: true },
    { no: 4, name: "delegated_vesting", kind: "message", T: coin_pb_js_1.Coin, repeated: true },
    { no: 5, name: "end_time", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
]);
/**
 * ContinuousVestingAccount implements the VestingAccount interface. It
 * continuously vests by unlocking coins linearly with respect to time.
 *
 * @generated from message cosmos.vesting.v1beta1.ContinuousVestingAccount
 */
class ContinuousVestingAccount extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * Vesting start time, as unix timestamp (in seconds).
         *
         * @generated from field: int64 start_time = 2;
         */
        this.startTime = protobuf_1.protoInt64.zero;
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new ContinuousVestingAccount().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ContinuousVestingAccount().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ContinuousVestingAccount().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(ContinuousVestingAccount, a, b);
    }
}
exports.ContinuousVestingAccount = ContinuousVestingAccount;
ContinuousVestingAccount.runtime = protobuf_1.proto3;
ContinuousVestingAccount.typeName = "cosmos.vesting.v1beta1.ContinuousVestingAccount";
ContinuousVestingAccount.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "base_vesting_account", kind: "message", T: BaseVestingAccount },
    { no: 2, name: "start_time", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
]);
/**
 * DelayedVestingAccount implements the VestingAccount interface. It vests all
 * coins after a specific time, but non prior. In other words, it keeps them
 * locked until a specified time.
 *
 * @generated from message cosmos.vesting.v1beta1.DelayedVestingAccount
 */
class DelayedVestingAccount extends protobuf_1.Message {
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new DelayedVestingAccount().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DelayedVestingAccount().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DelayedVestingAccount().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(DelayedVestingAccount, a, b);
    }
}
exports.DelayedVestingAccount = DelayedVestingAccount;
DelayedVestingAccount.runtime = protobuf_1.proto3;
DelayedVestingAccount.typeName = "cosmos.vesting.v1beta1.DelayedVestingAccount";
DelayedVestingAccount.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "base_vesting_account", kind: "message", T: BaseVestingAccount },
]);
/**
 * Period defines a length of time and amount of coins that will vest.
 *
 * @generated from message cosmos.vesting.v1beta1.Period
 */
class Period extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * Period duration in seconds.
         *
         * @generated from field: int64 length = 1;
         */
        this.length = protobuf_1.protoInt64.zero;
        /**
         * @generated from field: repeated cosmos.base.v1beta1.Coin amount = 2;
         */
        this.amount = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new Period().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Period().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Period().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Period, a, b);
    }
}
exports.Period = Period;
Period.runtime = protobuf_1.proto3;
Period.typeName = "cosmos.vesting.v1beta1.Period";
Period.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "length", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "amount", kind: "message", T: coin_pb_js_1.Coin, repeated: true },
]);
/**
 * PeriodicVestingAccount implements the VestingAccount interface. It
 * periodically vests by unlocking coins during each specified period.
 *
 * @generated from message cosmos.vesting.v1beta1.PeriodicVestingAccount
 */
class PeriodicVestingAccount extends protobuf_1.Message {
    constructor(data) {
        super();
        /**
         * @generated from field: int64 start_time = 2;
         */
        this.startTime = protobuf_1.protoInt64.zero;
        /**
         * @generated from field: repeated cosmos.vesting.v1beta1.Period vesting_periods = 3;
         */
        this.vestingPeriods = [];
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new PeriodicVestingAccount().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new PeriodicVestingAccount().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new PeriodicVestingAccount().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(PeriodicVestingAccount, a, b);
    }
}
exports.PeriodicVestingAccount = PeriodicVestingAccount;
PeriodicVestingAccount.runtime = protobuf_1.proto3;
PeriodicVestingAccount.typeName = "cosmos.vesting.v1beta1.PeriodicVestingAccount";
PeriodicVestingAccount.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "base_vesting_account", kind: "message", T: BaseVestingAccount },
    { no: 2, name: "start_time", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "vesting_periods", kind: "message", T: Period, repeated: true },
]);
/**
 * PermanentLockedAccount implements the VestingAccount interface. It does
 * not ever release coins, locking them indefinitely. Coins in this account can
 * still be used for delegating and for governance votes even while locked.
 *
 * Since: cosmos-sdk 0.43
 *
 * @generated from message cosmos.vesting.v1beta1.PermanentLockedAccount
 */
class PermanentLockedAccount extends protobuf_1.Message {
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
        return new PermanentLockedAccount().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new PermanentLockedAccount().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new PermanentLockedAccount().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(PermanentLockedAccount, a, b);
    }
}
exports.PermanentLockedAccount = PermanentLockedAccount;
PermanentLockedAccount.runtime = protobuf_1.proto3;
PermanentLockedAccount.typeName = "cosmos.vesting.v1beta1.PermanentLockedAccount";
PermanentLockedAccount.fields = protobuf_1.proto3.util.newFieldList(() => [
    { no: 1, name: "base_vesting_account", kind: "message", T: BaseVestingAccount },
]);
